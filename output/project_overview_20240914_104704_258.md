## Project_Analyzer.rb

```ruby
#!/usr/bin/env ruby

require 'fileutils'
require 'json'
require 'logger'
require 'pathname'
require 'optparse'
require 'ruby-progressbar'
require 'concurrent-ruby'

class ProjectAnalyzer
  def initialize(options)
    @input_dir = File.expand_path(options[:input_dir] || '.')
    @output_dir = options[:output_dir] || File.join(@input_dir, 'output')
    @output_file = options[:output_file] || "project_overview_#{Time.now.strftime('%Y%m%d_%H%M%S_%L')}"
    @extensions = options[:extensions] || ['.rb', '.json']
    @logger = options[:logger]
  end

  def run
    validate_input_directory
    files = get_relevant_files
    total_files = files.values.flatten.size

    if total_files.zero?
      @logger.error("No files found with extensions: #{@extensions.join(', ')}")
      return
    end

    write_output(files)
  end

  private

  def validate_input_directory
    unless Dir.exist?(@input_dir)
      @logger.error("Input directory does not exist: #{@input_dir}")
      exit(1)
    end
  end

  def get_relevant_files
    files = Hash.new { |hash, key| hash[key] = [] }
    @logger.info("Scanning directory: #{@input_dir}")

    Dir.glob(File.join(@input_dir, '**', '*')).each do |file|
      next unless File.file?(file)
      ext = File.extname(file)
      if @extensions.include?(ext)
        files[ext] << file
        @logger.debug("Found #{ext} file: #{file}")
      end
    end

    @extensions.each do |ext|
      @logger.info("#{ext} files found: #{files[ext]&.size || 0}")
    end

    files
  end

  def write_output(files)
    FileUtils.mkdir_p(@output_dir)
    output_path = File.join(@output_dir, "#{@output_file}.md")

    total_files = files.values.flatten.size
    progressbar = ProgressBar.create(total: total_files, format: "%a %e %P% Processed: %c from %C")

    File.open(output_path, 'w', encoding: 'UTF-8') do |out_file|
      files.each do |ext, file_list|
        language = ext_language(ext)
        file_list.sort.each do |file|
          relative_path = Pathname.new(file).relative_path_from(Pathname.new(@input_dir)).to_s
          out_file.puts "## #{relative_path}\n\n```#{language}"

          begin
            content = File.read(file, encoding: 'UTF-8')
            content = format_content(ext, content)
            out_file.puts content
            @logger.info("Processed #{relative_path}")
          rescue => e
            error_message = "Error reading #{relative_path}: #{e.message}"
            @logger.error(error_message)
            @logger.debug(e.backtrace.join("\n"))
            out_file.puts error_message
          end

          out_file.puts "```\n\n"
          progressbar.increment
        end
      end
    end

    @logger.info("Output written to #{output_path}")
    @logger.info("Total files processed: #{total_files}")
  end

  def ext_language(ext)
    case ext
    when '.rb' then 'ruby'
    when '.json' then 'json'
    else ext[1..-1] # Remove the dot
    end
  end

  def format_content(ext, content)
    if ext == '.json'
      JSON.pretty_generate(JSON.parse(content))
    else
      content
    end
  rescue JSON::ParserError => e
    @logger.warn("Failed to parse JSON: #{e.message}")
    content
  end
end

# Main execution starts here
options = {
  logger: Logger.new(STDOUT)
}

OptionParser.new do |opts|
  opts.banner = "Usage: project_analyzer.rb [options]"

  opts.on("-i", "--input DIR", "Input directory to scan") do |dir|
    options[:input_dir] = dir
  end

  opts.on("-o", "--output DIR", "Output directory") do |dir|
    options[:output_dir] = dir
  end

  opts.on("-f", "--file FILE", "Output file name (without extension)") do |file|
    options[:output_file] = file
  end

  opts.on("-l", "--log-level LEVEL", "Set log level (DEBUG, INFO, WARN, ERROR)") do |level|
    options[:log_level] = level
  end

  opts.on("-e", "--extensions x,y,z", Array, "File extensions to include (default: .rb,.json)") do |list|
    options[:extensions] = list.map { |ext| ext.start_with?('.') ? ext : ".#{ext}" }
  end

  opts.on("-h", "--help", "Displays Help") do
    puts opts
    exit
  end
end.parse!

# Set logging level
options[:logger].level = case options[:log_level]&.upcase
                         when 'DEBUG' then Logger::DEBUG
                         when 'WARN' then Logger::WARN
                         when 'ERROR' then Logger::ERROR
                         else Logger::INFO
                         end

options[:logger].formatter = proc do |severity, datetime, progname, msg|
  "#{datetime.strftime('%Y-%m-%d %H:%M:%S')} - #{severity} - #{msg}\n"
end

analyzer = ProjectAnalyzer.new(options)
analyzer.run
```

## bin/f100_to_spooky2.rb

```ruby
#!/usr/bin/env ruby

# Add the lib directory to the load path
$LOAD_PATH.unshift File.expand_path('../lib', __dir__)

require 'spooky2tool'
require 'clipboard'
require 'json'
require 'fileutils'

def read_clipboard_content
  content = Clipboard.paste
  content.encode!('UTF-8', 'UTF-8', invalid: :replace, undef: :replace, replace: '')

  if content.encoding == Encoding::UTF_16LE || content.start_with?("\xFF\xFE")
    content = content.encode('UTF-8', 'UTF-16LE')
  end

  content
end

def main
  # Check if we're being run by OCRA
  if defined?(Ocra)
    puts "OCRA is compiling the script. Skipping main functionality."
    return
  end

  logger = nil
  begin
    timestamp = Spooky2Tool::Utils.create_timestamp
    log_file = File.join(Dir.pwd, "spooky2tool_#{timestamp}.log")
    logger = Spooky2Tool::Utils.setup_logging(log_file: log_file, level: Logger::DEBUG)

    puts "Starting Spooky2Tool F100 to Spooky2 Preset Converter"
    puts "Current directory: #{Dir.pwd}"
    logger.info("Starting Spooky2Tool F100 to Spooky2 Preset Converter")
    logger.info("Current directory: #{Dir.pwd}")

    clipboard_content = read_clipboard_content
    puts "Clipboard content read (#{clipboard_content.length} characters)"
    logger.info("Clipboard content read (#{clipboard_content.length} characters)")
    logger.debug("Clipboard content:\n#{clipboard_content}")

    if clipboard_content.empty?
      error_msg = "Clipboard is empty or content couldn't be read. Please copy an F100 script to the clipboard."
      puts "Error: #{error_msg}"
      logger.error(error_msg)
      return
    end

    puts "Validating input..."
    logger.info("Validating input...")
    begin
      Spooky2Tool::Validator.validate_input(clipboard_content, logger)
    rescue Spooky2Tool::Validator::ValidationError => e
      error_msg = "Input validation failed: #{e.message}"
      puts "Error: The clipboard content is not a valid F100 script. #{e.message}"
      logger.error(error_msg)
      logger.error("Invalid clipboard content:\n#{clipboard_content}")
      return
    end

    puts "Input validation successful. Parsing F100 script..."
    logger.info("Input validation successful. Parsing F100 script...")
    parser = Spooky2Tool::Parser.new(logger)
    parsed_data = parser.parse(clipboard_content)
    logger.debug("Parsed data: #{parsed_data.inspect}")

    if parsed_data[:frequency_objects].empty?
      warn_msg = "No frequency objects were parsed from the input."
      puts "Warning: #{warn_msg}"
      logger.warn(warn_msg)
    end

    header_file = File.expand_path('../config/spooky2_preset_header.txt', __dir__)
    puts "Looking for header file: #{header_file}"
    logger.info("Looking for header file: #{header_file}")
    unless File.exist?(header_file)
      error_msg = "Header file not found: #{header_file}"
      puts "Error: Header file not found. Please ensure 'spooky2_preset_header.txt' is in the config directory."
      logger.error(error_msg)
      return
    end

    header_content = File.read(header_file)
    logger.debug("Header content read (#{header_content.length} characters)")

    puts "Generating Spooky2 preset..."
    logger.info("Generating Spooky2 preset...")
    generator = Spooky2Tool::Generator.new(logger)
    preset_content = generator.generate_spooky2_preset(parsed_data, header_content)

    output_file = generator.save_preset(preset_content, parsed_data[:header][:program_name])

    puts "Spooky2 preset generated successfully!"
    puts "Output file: #{output_file}"
    puts "Program name: #{parsed_data[:header][:program_name]}"
    puts "Number of frequency objects: #{parsed_data[:frequency_objects].size}"
    logger.info("Spooky2 preset generated successfully!")
    logger.info("Output file: #{output_file}")
    logger.info("Program name: #{parsed_data[:header][:program_name]}")
    logger.info("Number of frequency objects: #{parsed_data[:frequency_objects].size}")

    file_size = Spooky2Tool::Utils.get_file_size(output_file)
    puts "Output file size: #{file_size} bytes"
    logger.info("Output file size: #{file_size} bytes")

    metadata = {
      timestamp: timestamp,
      program_name: parsed_data[:header][:program_name],
      frequency_objects_count: parsed_data[:frequency_objects].size,
      output_file: output_file,
      file_size: file_size
    }
    Spooky2Tool::Utils.save_metadata(metadata, File.dirname(output_file))

    puts "For detailed logs, check: #{log_file}"

  rescue StandardError => e
    error_message = "An error occurred: #{e.message}"
    puts error_message
    puts e.backtrace.join("\n")
    if logger
      logger.error(error_message)
      logger.error(e.backtrace.join("\n"))
    end
    puts "An error occurred while processing the F100 script. Please check the logs for more information."
  ensure
    puts "Press Enter to exit."
    gets  # Wait for user input before closing
  end
end

main if __FILE__ == $PROGRAM_NAME
```

## lib/spooky2tool.rb

```ruby
require 'logger'

module Spooky2Tool
  VERSION = '0.1.0'
end

require_relative 'spooky2tool/utils'
require_relative 'spooky2tool/parser'
require_relative 'spooky2tool/formatter'
require_relative 'spooky2tool/generator'
require_relative 'spooky2tool/validator'  # Add this line
```

## lib/spooky2tool/formatter.rb

```ruby
module Spooky2Tool
  class Formatter
    attr_reader :logger

    def initialize(logger = Logger.new(STDOUT))
      @logger = logger
    end

    def format_frequencies(frequencies, fuzz, dwell_time)
      @logger.info("Formatting #{frequencies.size} frequencies with fuzz and dwell time")

      formatted_frequencies = frequencies.map do |freq|
        format_frequency(freq, fuzz, dwell_time)
      end

      @logger.info("Formatted #{formatted_frequencies.size} frequency ranges")
      formatted_frequencies
    end

    def apply_frequency_limits(formatted_frequencies, min_freq: 0.01, max_freq: 25_000_000)
      @logger.info("Applying frequency limits: min=#{min_freq} Hz, max=#{max_freq} Hz")

      limited_frequencies = formatted_frequencies.map do |freq_range|
        apply_limits_to_range(freq_range, min_freq, max_freq)
      end.compact

      @logger.info("Applied limits to #{limited_frequencies.size} frequency ranges")
      limited_frequencies
    end

    def group_frequencies(formatted_frequencies, max_group_size: 1000)
      @logger.info("Grouping frequencies with max group size of #{max_group_size}")

      grouped_frequencies = formatted_frequencies.each_slice(max_group_size).to_a

      @logger.info("Created #{grouped_frequencies.size} groups of frequencies")
      grouped_frequencies
    end

    private

    def format_frequency(freq, fuzz, dwell_time)
      lower_freq = freq * (1 - fuzz[0])
      upper_freq = freq * (1 + fuzz[1])

      if lower_freq == upper_freq
        format("%.5f=#{dwell_time}", lower_freq)
      else
        format("%.5f-%.5f=#{dwell_time}", lower_freq, upper_freq)
      end
    end

    def apply_limits_to_range(freq_range, min_freq, max_freq)
      lower, upper = freq_range.split('-').map(&:to_f)
      dwell_time = freq_range.split('=').last

      lower = [min_freq, [lower, max_freq].min].max
      upper = [min_freq, [upper, max_freq].min].max

      return nil if lower == upper

      format("%.5f-%.5f=#{dwell_time}", lower, upper)
    end
  end
end# frozen_string_literal: true

```

## lib/spooky2tool/generator.rb

```ruby
# File: lib/spooky2tool/generator.rb

require 'logger'
require 'fileutils'

module Spooky2Tool
  class Generator
    attr_reader :logger

    def initialize(logger = Logger.new(STDOUT))
      @logger = logger
    end

    def generate_spooky2_preset(parsed_data, header)
      logger.info("Generating Spooky2 preset")
      logger.debug("Parsed data: #{parsed_data.inspect}")
      logger.debug("Header: #{header.inspect}")

      preset_content = ['"[Preset]"']
      preset_content += process_header(header, parsed_data[:header][:program_name])

      if parsed_data[:frequency_objects].empty?
        logger.warn("No frequency objects found in parsed data")
      else
        last_freq_obj = parsed_data[:frequency_objects].last
        preset_content << generate_loaded_programs(last_freq_obj)
        preset_content << generate_loaded_frequencies([last_freq_obj])
      end

      preset_content << '"[/Preset]"'

      logger.info("Spooky2 preset generated successfully")
      preset_content.join("\n")
    end

    def save_preset(preset_content, program_name)
      spooky2_dir = 'C:\Spooky2\Preset Collections\User\Biofeedback'
      if Dir.exist?(spooky2_dir)
        output_dir = spooky2_dir
      else
        output_dir = File.join(Dir.pwd, 'output')
        FileUtils.mkdir_p(output_dir)
      end

      sanitized_name = program_name.gsub(/[^\w\s-]/, '').gsub(/\s+/, '_')
      output_file = File.join(output_dir, "#{sanitized_name}.txt")

      File.write(output_file, preset_content)
      logger.info("Preset saved to: #{output_file}")
      output_file
    end

    private

    def process_header(header, program_name)
      header_content = header.strip.split("\n")

      # Remove any existing "[Preset]" lines
      header_content.reject! { |line| line.strip == '"[Preset]"' }

      processed_header = header_content.map do |line|
        if line.start_with?('"PresetName=')
          "\"PresetName=#{program_name}\""
        else
          line
        end
      end

      processed_header
    end

    def generate_loaded_programs(freq_obj)
      "\"Loaded_Programs=#{freq_obj[:name]} #{freq_obj[:dates].join(' ')}\""
    end

    def generate_loaded_frequencies(frequency_objects)
      frequencies = frequency_objects.flat_map do |freq_obj|
        freq_obj[:fuzz_frequency_pairs].flat_map do |pair|
          format_frequencies(pair[:frequencies], pair[:fuzz], pair[:dwell] || 60)
        end
      end

      "\"Loaded_Frequencies=#{frequencies.join(',')}\""
    end

    def format_frequencies(frequencies, fuzz, dwell)
      frequencies.map do |freq|
        if fuzz[0] == 0 && fuzz[1] == 0
          format("%.8f=%d", freq, dwell)
        else
          lower = freq * (1 - fuzz[0])
          upper = freq * (1 + fuzz[1])
          format("%.8f-%.8f=%d", lower, upper, dwell)
        end
      end
    end
  end
end
```

## lib/spooky2tool/parser.rb

```ruby
# lib/spooky2tool/parser.rb

module Spooky2Tool
  class Parser
    attr_reader :logger

    def initialize(logger = Logger.new(STDOUT))
      @logger = logger
    end

    def parse(content)
      lines = content.split("\n")
      @logger.debug("Parsing #{lines.size} lines")
      result = {
        header: parse_header(lines),
        frequency_objects: parse_frequency_objects(lines)
      }
      @logger.debug("Parsed result: #{result.inspect}")
      result
    end

    private

    def parse_header(lines)
      header = {
        program_name: nil,
        dates: [],
        copyright: nil,
        keywords: [],
        settings: {}
      }

      lines.each do |line|
        case line
        when /^#(.+)$/
          if header[:program_name].nil?
            header[:program_name] = $1.strip
            header[:dates] = $1.scan(/\d{8}/)
          elsif line =~ /^#copyright/i
            header[:copyright] = line.sub(/^#/, '').strip
          else
            header[:keywords] << line.sub(/^#/, '').strip
          end
        when /^(repeat|dwell|program)\s+(.+)$/i
          header[:settings][$1.downcase] = $2
        when /^$/
          next
        else
          break
        end
      end

      @logger.debug("Parsed header: #{header.inspect}")
      header
    end

    def parse_frequency_objects(lines)
      objects = []
      current_object = nil

      lines.each do |line|
        case line
        when /^#(\S+.*?)\s+(\d{8}(?:\s+\d{8})*)$/
          objects << current_object if current_object && !current_object[:fuzz_frequency_pairs].empty?
          current_object = {
            name: $1,
            dates: $2.split,
            fuzz_frequency_pairs: []
          }
        when /^fuzz\s+(.+)$/
          if current_object
            current_object[:fuzz_frequency_pairs] << {
              fuzz: parse_fuzz($1),
              frequencies: [],
              dwell: 60  # Default dwell time
            }
          else
            @logger.warn("Found fuzz command outside of a frequency object: #{line}")
          end
        when /^dwell\s+(\d+)$/
          if current_object && !current_object[:fuzz_frequency_pairs].empty?
            current_object[:fuzz_frequency_pairs].last[:dwell] = $1.to_i
          else
            @logger.warn("Found dwell command in unexpected location: #{line}")
          end
        when /^\s*[\d.]+/
          if current_object && !current_object[:fuzz_frequency_pairs].empty?
            current_object[:fuzz_frequency_pairs].last[:frequencies] += line.split.map(&:to_f)
          else
            @logger.warn("Found frequencies outside of a fuzz-frequency pair: #{line}")
          end
        end
      end

      objects << current_object if current_object && !current_object[:fuzz_frequency_pairs].empty?
      @logger.debug("Parsed #{objects.size} frequency objects")
      objects
    end

    def parse_fuzz(fuzz_string)
      fuzz_string.split.map { |f| f.sub('%', '').to_f / 100 }
    end
  end
end
```

## lib/spooky2tool/utils.rb

```ruby
# lib/spooky2tool/utils.rb

require 'logger'
require 'fileutils'
require 'json'

module Spooky2Tool
  module Utils
    def self.setup_logging(log_file: 'spooky2tool.log', level: Logger::INFO)
      FileUtils.mkdir_p(File.dirname(log_file))

      file_logger = Logger.new(log_file)
      console_logger = Logger.new(STDOUT)

      [file_logger, console_logger].each do |logger|
        logger.level = level
        logger.formatter = proc do |severity, datetime, progname, msg|
          formatted_datetime = datetime.strftime("%Y-%m-%d %H:%M:%S")
          "[#{formatted_datetime}] #{severity}: #{msg}\n"
        end
      end

      combined_logger = Logger.new(log_file)
      combined_logger.level = level
      combined_logger.formatter = file_logger.formatter

      def combined_logger.add(severity, message = nil, progname = nil)
        super
        puts "#{formatter.call(severity, Time.now, progname, message)}"
      end

      combined_logger
    end

    def self.create_timestamp
      Time.now.strftime("%Y%m%d_%H%M%S")
    end

    def self.save_metadata(metadata, output_dir, filename: 'metadata.json')
      filepath = File.join(output_dir, filename)
      FileUtils.mkdir_p(output_dir) unless Dir.exist?(output_dir)

      File.open(filepath, 'w') do |file|
        file.write(JSON.pretty_generate(metadata))
      end

      puts "Metadata saved to #{filepath}"
    rescue IOError => e
      puts "Error saving metadata to #{filepath}: #{e.message}"
    end

    def self.ensure_directory_exists(directory)
      FileUtils.mkdir_p(directory) unless Dir.exist?(directory)
      puts "Created directory: #{directory}"
    end

    def self.get_file_size(filepath)
      File.size(filepath)
    rescue Errno::ENOENT => e
      puts "Error getting file size for #{filepath}: #{e.message}"
      0
    end

    def self.is_valid_frequency?(freq, min_freq: 0.01, max_freq: 25_000_000)
      freq >= min_freq && freq <= max_freq
    end
  end
end
```

## lib/spooky2tool/validator.rb

```ruby
# lib/spooky2tool/validator.rb

module Spooky2Tool
  class Validator
    class ValidationError < StandardError; end

    def self.validate_input(content, logger)
      logger.info("Starting validation of input")
      raise ValidationError, "Input is empty" if content.strip.empty?
      validate_structure(content, logger)
      validate_header(content, logger)
      validate_frequency_blocks(content, logger)
      logger.info("Input validation completed successfully")
    end

    def self.validate_structure(content, logger)
      logger.info("Validating structure")
      lines = content.split("\n")
      raise ValidationError, "No header found" unless lines.any? { |line| line.start_with?('#') }
      raise ValidationError, "No frequency data found" unless lines.any? { |line| line.match?(/^\d/) }
    end

    def self.validate_header(content, logger)
      logger.info("Validating header")
      first_line = content.split("\n").first
      unless first_line.match?(/^#.+\s\d{8}$/)
        raise ValidationError, "Invalid header format. Expected: #Program Name YYYYMMDD"
      end
    end

    def self.validate_frequency_blocks(content, logger)
      logger.info("Validating frequency blocks")
      lines = content.split("\n")
      fuzz_lines = lines.select { |line| line.start_with?('fuzz') }
      raise ValidationError, "No fuzz commands found" if fuzz_lines.empty?

      fuzz_lines.each do |fuzz_line|
        unless fuzz_line.match?(/^fuzz\s+((\d+(\.\d+)?%?)|(\.\d+%?))\s+((\d+(\.\d+)?%?)|(\.\d+%?))$/)
          raise ValidationError, "Invalid fuzz command: #{fuzz_line}"
        end
      end

      freq_lines = lines.select { |line| line.match?(/^\d/) }
      freq_lines.each do |freq_line|
        frequencies = freq_line.split.map(&:to_f)
        frequencies.each do |freq|
          unless freq > 0 && freq < 60_000_000  # 60 MHz
            raise ValidationError, "Invalid frequency: #{freq}. Must be greater than 0 and less than 60 MHz."
          end
        end
      end
    end
  end
end
```

## spec/formatter_spec.rb

```ruby
require 'spec_helper'
require_relative '../lib/spooky2tool/formatter'

RSpec.describe Spooky2Tool::Formatter do
  let(:formatter) { Spooky2Tool::Formatter.new }

  describe '#format_frequencies' do
    it 'formats single frequencies correctly' do
      frequencies = [100, 200, 300]
      fuzz = [0, 0]
      dwell_time = 60

      result = formatter.format_frequencies(frequencies, fuzz, dwell_time)

      expect(result).to eq(['100.00000000=60', '200.00000000=60', '300.00000000=60'])
    end

    it 'applies fuzz correctly' do
      frequencies = [100, 200, 300]
      fuzz = [0.01, 0.02]  # 1% lower, 2% upper
      dwell_time = 60

      result = formatter.format_frequencies(frequencies, fuzz, dwell_time)

      expect(result).to eq([
                             '99.00000000-102.00000000=60',
                             '198.00000000-204.00000000=60',
                             '297.00000000-306.00000000=60'
                           ])
    end

    it 'uses the provided dwell time' do
      frequencies = [100]
      fuzz = [0, 0]
      dwell_time = 30

      result = formatter.format_frequencies(frequencies, fuzz, dwell_time)

      expect(result).to eq(['100.00000000=30'])
    end
  end

  describe '#apply_frequency_limits' do
    it 'applies minimum frequency limit' do
      formatted_frequencies = ['0.00500000=60', '10.00000000=60']
      result = formatter.apply_frequency_limits(formatted_frequencies, min_freq: 0.01)

      expect(result).to eq(['0.01000000=60', '10.00000000=60'])
    end

    it 'applies maximum frequency limit' do
      formatted_frequencies = ['10000000.00000000=60', '30000000.00000000=60']
      result = formatter.apply_frequency_limits(formatted_frequencies, max_freq: 25000000)

      expect(result).to eq(['10000000.00000000=60', '25000000.00000000=60'])
    end

    it 'handles frequency ranges correctly' do
      formatted_frequencies = ['9.00000000-11.00000000=60', '24000000.00000000-26000000.00000000=60']
      result = formatter.apply_frequency_limits(formatted_frequencies, min_freq: 10, max_freq: 25000000)

      expect(result).to eq(['10.00000000-11.00000000=60', '24000000.00000000-25000000.00000000=60'])
    end
  end

  describe '#group_frequencies' do
    it 'groups frequencies into sets of specified size' do
      formatted_frequencies = (1..1500).map { |i| "#{i}.00000000=60" }
      result = formatter.group_frequencies(formatted_frequencies, max_group_size: 1000)

      expect(result.size).to eq(2)
      expect(result[0].size).to eq(1000)
      expect(result[1].size).to eq(500)
    end
  end

  describe '#format_section' do
    it 'formats a complete section' do
      section = {
        name: 'Test Section',
        frequencies: [100, 200, 300],
        fuzz: [0.01, 0.02],
        dwell_time: 60
      }

      section_name, grouped_freqs = formatter.format_section(section)

      expect(section_name).to eq('Test Section')
      expect(grouped_freqs).to be_an(Array)
      expect(grouped_freqs.first).to include('99.00000000-102.00000000=60')
    end
  end
end
```

## spec/generator_spec.rb

```ruby
require 'spec_helper'
require_relative '../lib/spooky2tool/generator'

RSpec.describe Spooky2Tool::Generator do
  let(:generator) { Spooky2Tool::Generator.new }

  describe '#generate_spooky2_preset' do
    let(:parsed_data) do
      {
        header: {
          program_name: "Test Program",
          dates: ["20240913"],
          copyright: "Copyright 2024",
          keywords: ["test", "spooky2"],
          settings: { "repeat" => "4", "dwell" => "60" }
        },
        frequency_objects: [
          {
            name: "Test Frequency Set",
            dates: ["20240913"],
            fuzz_frequency_pairs: [
              {
                fuzz: [0.01, 1],
                frequencies: [100, 200, 300],
                dwell: 60
              },
              {
                fuzz: [0, 0],
                frequencies: [400, 500, 600],
                dwell: 30
              }
            ]
          }
        ]
      }
    end

    let(:header_content) do
      <<~HEADER
        "[Preset]"
        "PresetName=PLACEHOLDER"
        "Repeat_Each_Frequency=1"
        "Out1_Amplitude=20"
      HEADER
    end

    it 'generates a valid Spooky2 preset' do
      preset = generator.generate_spooky2_preset(parsed_data, header_content)

      expect(preset).to include('"[Preset]"')
      expect(preset).to include('"PresetName=Test Program"')
      expect(preset).to include('"Loaded_Programs=Test Frequency Set 20240913"')
      expect(preset).to include('"Loaded_Frequencies=')
      expect(preset).to include('99.00000000-101.00000000=60')
      expect(preset).to include('400.00000000=30')
      expect(preset).to include('"[/Preset]"')
    end

    it 'includes all frequencies from all frequency objects' do
      preset = generator.generate_spooky2_preset(parsed_data, header_content)

      parsed_data[:frequency_objects].first[:fuzz_frequency_pairs].each do |pair|
        pair[:frequencies].each do |freq|
          expect(preset).to include(freq.to_s)
        end
      end
    end

    it 'applies fuzz correctly' do
      preset = generator.generate_spooky2_preset(parsed_data, header_content)

      expect(preset).to include('99.00000000-101.00000000=60')  # 100 Hz with 1% fuzz
      expect(preset).to include('198.00000000-202.00000000=60') # 200 Hz with 1% fuzz
      expect(preset).to include('297.00000000-303.00000000=60') # 300 Hz with 1% fuzz
    end

    it 'uses correct dwell times' do
      preset = generator.generate_spooky2_preset(parsed_data, header_content)

      expect(preset).to include('=60') # For the first fuzz_frequency_pair
      expect(preset).to include('=30') # For the second fuzz_frequency_pair
    end
  end
end
```

## spec/parser_spec.rb

```ruby

require 'spec_helper'
require_relative '../lib/spooky2tool/parser'

RSpec.describe F100Parser do
  let(:parser) { F100Parser.new }

  describe '#parse' do
    context 'with a valid F100 script' do
      let(:valid_script) do
        <<~SCRIPT
          #Sample F100 Program 20240913
          #copyright 2024 Example Corp.
          #keyword1
          #keyword2
          repeat 4
          dwell 60
          #Frequency Set A 20240913 20240914
          fuzz 1% 1
          100
          200
          300
          fuzz 0 0
          400
          500
          600
          #Frequency Set B 20240915
          fuzz 2% 2
          700
          800
          900
        SCRIPT
      end

      it 'correctly parses the header' do
        result = parser.parse(valid_script)
        expect(result[:header][:program_name]).to eq('Sample F100 Program')
        expect(result[:header][:dates]).to eq(['20240913'])
        expect(result[:header][:copyright]).to eq('copyright 2024 Example Corp.')
        expect(result[:header][:keywords]).to contain_exactly('keyword1', 'keyword2')
        expect(result[:header][:settings]).to include('repeat' => '4', 'dwell' => '60')
      end

      it 'correctly parses frequency objects' do
        result = parser.parse(valid_script)
        expect(result[:frequency_objects].size).to eq(2)

        set_a = result[:frequency_objects][0]
        expect(set_a[:name]).to eq('Frequency Set A')
        expect(set_a[:dates]).to eq(['20240913', '20240914'])
        expect(set_a[:fuzz_frequency_pairs].size).to eq(2)
        expect(set_a[:fuzz_frequency_pairs][0][:fuzz]).to eq([0.01, 1])
        expect(set_a[:fuzz_frequency_pairs][0][:frequencies]).to eq([100, 200, 300])
        expect(set_a[:fuzz_frequency_pairs][1][:fuzz]).to eq([0, 0])
        expect(set_a[:fuzz_frequency_pairs][1][:frequencies]).to eq([400, 500, 600])

        set_b = result[:frequency_objects][1]
        expect(set_b[:name]).to eq('Frequency Set B')
        expect(set_b[:dates]).to eq(['20240915'])
        expect(set_b[:fuzz_frequency_pairs].size).to eq(1)
        expect(set_b[:fuzz_frequency_pairs][0][:fuzz]).to eq([0.02, 2])
        expect(set_b[:fuzz_frequency_pairs][0][:frequencies]).to eq([700, 800, 900])
      end
    end

    context 'with an empty script' do
      it 'returns an empty result' do
        result = parser.parse('')
        expect(result[:header]).to eq({program_name: nil, dates: [], copyright: nil, keywords: [], settings: {}})
        expect(result[:frequency_objects]).to be_empty
      end
    end

    context 'with a script containing only header information' do
      let(:header_only_script) do
        <<~SCRIPT
          #Header Only Program 20240913
          #copyright 2024 Example Corp.
          #keyword
          repeat 2
        SCRIPT
      end

      it 'correctly parses the header and returns no frequency objects' do
        result = parser.parse(header_only_script)
        expect(result[:header][:program_name]).to eq('Header Only Program')
        expect(result[:header][:dates]).to eq(['20240913'])
        expect(result[:header][:copyright]).to eq('copyright 2024 Example Corp.')
        expect(result[:header][:keywords]).to contain_exactly('keyword')
        expect(result[:header][:settings]).to include('repeat' => '2')
        expect(result[:frequency_objects]).to be_empty
      end
    end

    context 'with a script containing invalid data' do
      let(:invalid_script) do
        <<~SCRIPT
          Invalid content
          100 200 300
          #Not a proper header
        SCRIPT
      end

      it 'handles the invalid data gracefully' do
        result = parser.parse(invalid_script)
        expect(result[:header]).to eq({program_name: nil, dates: [], copyright: nil, keywords: [], settings: {}})
        expect(result[:frequency_objects]).to be_empty
      end
    end

    context 'with various fuzz commands' do
      let(:fuzz_script) do
        <<~SCRIPT
          #Fuzz Test Program 20240913
          #Fuzz Set A 20240913
          fuzz 0 0
          100
          200
          fuzz 1% 1
          300
          400
          fuzz 2.5% 3
          500
          600
        SCRIPT
      end

      it 'correctly parses different fuzz commands' do
        result = parser.parse(fuzz_script)
        fuzz_pairs = result[:frequency_objects][0][:fuzz_frequency_pairs]

        expect(fuzz_pairs[0][:fuzz]).to eq([0, 0])
        expect(fuzz_pairs[1][:fuzz]).to eq([0.01, 1])
        expect(fuzz_pairs[2][:fuzz]).to eq([0.025, 3])
      end
    end
  end
end# frozen_string_literal: true

```

## spec/project_analyzer_spec.rb

```ruby
# spec/project_analyzer_spec.rb
require 'rspec'
require_relative '../project_analyzer'

RSpec.describe ProjectAnalyzer do
  let(:options) { { input_dir: 'spec/fixtures', logger: Logger.new('/dev/null') } }
  let(:analyzer) { ProjectAnalyzer.new(options) }

  describe '#get_relevant_files' do
    it 'finds the correct number of files' do
      files = analyzer.send(:get_relevant_files)
      expect(files['.rb'].size).to eq(2)  # Adjust based on your test fixtures
      expect(files['.json'].size).to eq(1)
    end
  end
end
# frozen_string_literal: true

```

## spec/spec_helper.rb

```ruby
# This file was generated by the `rspec --init` command. Conventionally, all
# specs live under a `spec` directory, which RSpec adds to the `$LOAD_PATH`.
# The generated `.rspec` file contains `--require spec_helper` which will cause
# this file to always be loaded, without a need to explicitly require it in any
# files.
#
# Given that it is always loaded, you are encouraged to keep this file as
# light-weight as possible. Requiring heavyweight dependencies from this file
# will add to the boot time of your test suite on EVERY test run, even for an
# individual file that may not need all of that loaded. Instead, consider making
# a separate helper file that requires the additional dependencies and performs
# the additional setup, and require it from the spec files that actually need
# it.
#
# See https://rubydoc.info/gems/rspec-core/RSpec/Core/Configuration
RSpec.configure do |config|
  # rspec-expectations config goes here. You can use an alternate
  # assertion/expectation library such as wrong or the stdlib/minitest
  # assertions if you prefer.
  config.expect_with :rspec do |expectations|
    # This option will default to `true` in RSpec 4. It makes the `description`
    # and `failure_message` of custom matchers include text for helper methods
    # defined using `chain`, e.g.:
    #     be_bigger_than(2).and_smaller_than(4).description
    #     # => "be bigger than 2 and smaller than 4"
    # ...rather than:
    #     # => "be bigger than 2"
    expectations.include_chain_clauses_in_custom_matcher_descriptions = true
  end

  # rspec-mocks config goes here. You can use an alternate test double
  # library (such as bogus or mocha) by changing the `mock_with` option here.
  config.mock_with :rspec do |mocks|
    # Prevents you from mocking or stubbing a method that does not exist on
    # a real object. This is generally recommended, and will default to
    # `true` in RSpec 4.
    mocks.verify_partial_doubles = true
  end

  # This option will default to `:apply_to_host_groups` in RSpec 4 (and will
  # have no way to turn it off -- the option exists only for backwards
  # compatibility in RSpec 3). It causes shared context metadata to be
  # inherited by the metadata hash of host groups and examples, rather than
  # triggering implicit auto-inclusion in groups with matching metadata.
  config.shared_context_metadata_behavior = :apply_to_host_groups

# The settings below are suggested to provide a good initial experience
# with RSpec, but feel free to customize to your heart's content.
=begin
  # This allows you to limit a spec run to individual examples or groups
  # you care about by tagging them with `:focus` metadata. When nothing
  # is tagged with `:focus`, all examples get run. RSpec also provides
  # aliases for `it`, `describe`, and `context` that include `:focus`
  # metadata: `fit`, `fdescribe` and `fcontext`, respectively.
  config.filter_run_when_matching :focus

  # Allows RSpec to persist some state between runs in order to support
  # the `--only-failures` and `--next-failure` CLI options. We recommend
  # you configure your source control system to ignore this file.
  config.example_status_persistence_file_path = "spec/examples.txt"

  # Limits the available syntax to the non-monkey patched syntax that is
  # recommended. For more details, see:
  # https://rspec.info/features/3-12/rspec-core/configuration/zero-monkey-patching-mode/
  config.disable_monkey_patching!

  # This setting enables warnings. It's recommended, but in some cases may
  # be too noisy due to issues in dependencies.
  config.warnings = true

  # Many RSpec users commonly either run the entire suite or an individual
  # file, and it's useful to allow more verbose output when running an
  # individual spec file.
  if config.files_to_run.one?
    # Use the documentation formatter for detailed output,
    # unless a formatter has already been configured
    # (e.g. via a command-line flag).
    config.default_formatter = "doc"
  end

  # Print the 10 slowest examples and example groups at the
  # end of the spec run, to help surface which specs are running
  # particularly slow.
  config.profile_examples = 10

  # Run specs in random order to surface order dependencies. If you find an
  # order dependency and want to debug it, you can fix the order by providing
  # the seed, which is printed after each run.
  #     --seed 1234
  config.order = :random

  # Seed global randomization in this process using the `--seed` CLI option.
  # Setting this allows you to use `--seed` to deterministically reproduce
  # test failures related to randomization by passing the same `--seed` value
  # as the one that triggered the failure.
  Kernel.srand config.seed
=end
end
```

## spec/utils_spec.rb

```ruby
require 'spec_helper'
require_relative '../lib/spooky2tool/utils'
require 'tempfile'
require 'logger'

RSpec.describe Spooky2Tool::Utils do
  describe '.setup_logging' do
    it 'creates a logger with the specified level' do
      logger = Spooky2Tool::Utils.setup_logging(level: Logger::DEBUG)
      expect(logger).to be_a(Logger)
      expect(logger.level).to eq(Logger::DEBUG)
    end

    it 'creates a log file' do
      log_file = 'test_log.log'
      logger = Spooky2Tool::Utils.setup_logging(log_file: log_file)
      expect(File.exist?(log_file)).to be true
      File.delete(log_file)
    end
  end

  describe '.create_timestamp' do
    it 'returns a string in the correct format' do
      timestamp = Spooky2Tool::Utils.create_timestamp
      expect(timestamp).to match(/\d{8}_\d{6}/)
    end
  end

  describe '.save_metadata' do
    it 'saves metadata to a JSON file' do
      metadata = { 'key' => 'value' }
      output_dir = Dir.mktmpdir
      filename = 'test_metadata.json'

      Spooky2Tool::Utils.save_metadata(metadata, output_dir, filename: filename)

      full_path = File.join(output_dir, filename)
      expect(File.exist?(full_path)).to be true
      content = JSON.parse(File.read(full_path))
      expect(content).to eq(metadata)

      FileUtils.remove_entry(output_dir)
    end
  end

  describe '.ensure_directory_exists' do
    it 'creates a directory if it does not exist' do
      dir = File.join(Dir.tmpdir, 'test_dir')
      Spooky2Tool::Utils.ensure_directory_exists(dir)
      expect(Dir.exist?(dir)).to be true
      Dir.rmdir(dir)
    end

    it 'does not raise an error if the directory already exists' do
      dir = Dir.mktmpdir
      expect {
        Spooky2Tool::Utils.ensure_directory_exists(dir)
      }.not_to raise_error
      FileUtils.remove_entry(dir)
    end
  end

  describe '.get_file_size' do
    it 'returns the correct file size' do
      file = Tempfile.new('test')
      file.write('test content')
      file.close

      size = Spooky2Tool::Utils.get_file_size(file.path)
      expect(size).to eq(12)  # 'test content' is 12 bytes

      file.unlink
    end

    it 'returns 0 for non-existent files' do
      size = Spooky2Tool::Utils.get_file_size('non_existent_file.txt')
      expect(size).to eq(0)
    end
  end

  describe '.is_valid_frequency?' do
    it 'returns true for frequencies within the valid range' do
      expect(Spooky2Tool::Utils.is_valid_frequency?(100)).to be true
      expect(Spooky2Tool::Utils.is_valid_frequency?(0.01)).to be true
      expect(Spooky2Tool::Utils.is_valid_frequency?(25000000)).to be true
    end

    it 'returns false for frequencies outside the valid range' do
      expect(Spooky2Tool::Utils.is_valid_frequency?(0)).to be false
      expect(Spooky2Tool::Utils.is_valid_frequency?(25000001)).to be false
    end
  end
end
```

## output/metadata.json

```json
{
  "timestamp": "20240913_124335",
  "program_name": "112549_morgellons 345454 20240913",
  "frequency_objects_count": 1,
  "output_file": "/Users/jeffsutherland/Frequency Research Foundation Inc. Dropbox/Frequency Lab/Ruby/ruby spooky2tool/output/112549_morgellons_345454_20240913.txt",
  "file_size": 6806
}
```

